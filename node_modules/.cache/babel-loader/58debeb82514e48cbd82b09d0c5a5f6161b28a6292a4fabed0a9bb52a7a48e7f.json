{"ast":null,"code":"import React,{useState,useEffect}from'react';import{GameBoard}from'./components/GameBoard';import{PlayerInfo}from'./components/PlayerInfo';import{ShopArea}from'./components/ShopArea';import{HandArea}from'./components/HandArea';import{GameOver}from'./components/GameOver';import{initializeGameState,drawCards,checkGameOver,resetGridForNewTurn,applyDamageToGrid,generateShopCards,applyLandBenefit,applyCardEffectToTile,applyStoneSkinEffect,generatePendingAttacks}from'./utils/gameUtils';import{createWoundCard}from'./data/cards';import{shuffleDeck}from'./utils/cardUtils';import'./App.css';import{jsx as _jsx,jsxs as _jsxs}from\"react/jsx-runtime\";const App=()=>{var _gameState$specialSta3;const[gameState,setGameState]=useState(null);const[cardSelectionMode,setCardSelectionMode]=useState(null);const[missileDomeSelection,setMissileDomeSelection]=useState(null);// Initialize game\nuseEffect(()=>{// Initialize with cards from our hardcoded set\nconst initialState=initializeGameState();setGameState(initialState);},[]);if(!gameState){return/*#__PURE__*/_jsx(\"div\",{className:\"loading\",children:\"Loading game data...\"});}// Handle card selection from hand\nconst handleCardSelect=card=>{if(missileDomeSelection){// If in missile dome selection mode, ignore card selection\nreturn;}if(cardSelectionMode==='discard'){var _gameState$specialSta;// In discard mode (for Archives card)\nconst discardedCards=((_gameState$specialSta=gameState.specialState)===null||_gameState$specialSta===void 0?void 0:_gameState$specialSta.type)==='archives'?gameState.specialState.data.discardedCards||[]:[];// Toggle card selection for discard\nif(discardedCards.some(c=>c.id===card.id)){// Remove from discard selection\nconst newDiscardedCards=discardedCards.filter(c=>c.id!==card.id);setGameState(prev=>({...prev,specialState:{type:'archives',data:{...prev.specialState.data,discardedCards:newDiscardedCards}}}));}else{// Add to discard selection\nsetGameState(prev=>({...prev,specialState:{type:'archives',data:{...prev.specialState.data,discardedCards:[...discardedCards,card]}}}));}}else{// Regular card selection mode\nsetGameState(prev=>{var _selectedCard;return{...prev,selectedCard:((_selectedCard=prev.selectedCard)===null||_selectedCard===void 0?void 0:_selectedCard.id)===card.id?null:card};});}};// Handle card placement on grid\nconst handleCardPlacement=(rowIndex,colIndex)=>{// Handle missile dome selection mode\nif(missileDomeSelection){if(missileDomeSelection.tilesSelected.length<missileDomeSelection.tilesNeeded){// Add this tile to missile dome selection if not already selected\nif(!missileDomeSelection.tilesSelected.some(_ref=>{let[r,c]=_ref;return r===rowIndex&&c===colIndex;})){const newSelection={tilesSelected:[...missileDomeSelection.tilesSelected,[rowIndex,colIndex]],tilesNeeded:missileDomeSelection.tilesNeeded};setMissileDomeSelection(newSelection);// If we've selected all needed tiles, apply the defense\nif(newSelection.tilesSelected.length===newSelection.tilesNeeded){const newGrid=JSON.parse(JSON.stringify(gameState.grid));// Apply defense to selected tiles\nnewSelection.tilesSelected.forEach(_ref2=>{let[r,c]=_ref2;newGrid[r][c].defense+=4;// Missile dome provides +4 defense\n});// Finish the missile dome action\nsetTimeout(()=>{setMissileDomeSelection(null);setGameState(prev=>({...prev,grid:newGrid}));},500);}}}return;}if(!gameState.selectedCard)return;// Check if a card has already been played on this tile\nif(gameState.grid[rowIndex][colIndex].cardPlayed)return;// Check if player has enough card plays\nif(gameState.player.cardPlays<=0)return;const card=gameState.selectedCard;// Track tiles that have cards played on them in this turn\nconst tileMap=new Map();// Create a deep copy of the grid\nlet newGrid=JSON.parse(JSON.stringify(gameState.grid));// Apply the basic card effect to the tile\nconst{grid:updatedGrid,tilesModified}=applyCardEffectToTile(newGrid,rowIndex,colIndex,card,tileMap);newGrid=updatedGrid;// Calculate effects from the card\nlet newPlayerState={...gameState.player};// Decrease card plays\nnewPlayerState.cardPlays-=1;// Apply card effects\nif(card.effects.gold){newPlayerState.gold+=card.effects.gold;}if(card.effects.buy){newPlayerState.buys+=card.effects.buy;}if(card.effects.card_play){newPlayerState.cardPlays+=card.effects.card_play;}if(card.effects.tech){newPlayerState.techTier=card.effects.tech;if(newPlayerState.techTier>5){newPlayerState.techTier=5;}}// Handle special effects\nlet specialState=gameState.specialState;if(card.effects.special_effect==='missile_dome'){// Enter missile dome selection mode - handled by a different function\nsetMissileDomeSelection({tilesSelected:[[rowIndex,colIndex]],// The initial tile is already selected\ntilesNeeded:2// Missile dome defends 2 tiles\n});}else if(card.effects.special_effect==='archives'){// Enter archives mode - discard and draw\nspecialState={type:'archives',data:{discardedCards:[]}};setCardSelectionMode('discard');}else if(card.effects.special_effect==='stone_skin'){// Apply Stone Skin effect to all tiles that had cards played on them\nnewGrid=applyStoneSkinEffect(newGrid,tileMap);}else if(card.effects.special_effect==='gold_rush'){// Track gold rush effect for next turn\nsetGameState(prev=>({...prev,goldRushEffects:(prev.goldRushEffects||0)+2}));}// Apply land benefit if card has that effect\nconst tile=gameState.grid[rowIndex][colIndex];if(card.effects.land_benefit){const{playerAttributes,partialBenefits}=applyLandBenefit(tile.landType,newPlayerState,card.effects.land_benefit_double,gameState.partialLandBenefits);newPlayerState=playerAttributes;// Update game state with new partial benefits\nsetGameState(prev=>({...prev,partialLandBenefits:partialBenefits}));}// Apply conditional effects based on land type\nif(card.effects.conditional_effect&&card.effects.conditional_effect.condition==='land_type'&&card.effects.conditional_effect.land_type===tile.landType){if(card.effects.conditional_effect.effects.gold){newPlayerState.gold+=card.effects.conditional_effect.effects.gold;}if(card.effects.conditional_effect.effects.draw){// Will handle card drawing later\n}}// Handle card drawing effects\nlet newHand=[...gameState.hand];let newDeck=[...gameState.deck];let newDiscard=[...gameState.discard];// Remove the played card from hand (unless it's a special effect that stays in play)\nnewHand=newHand.filter(c=>c.id!==card.id);// Add the played card to the discard pile\nnewDiscard.push(card);// Handle card draw effects\nlet drawCount=0;if(card.effects.draw){drawCount+=card.effects.draw;}// Add card draw from land benefit if applicable\nif(card.effects.land_benefit&&tile.landType==='card'){drawCount+=1*(card.effects.land_benefit_double?2:1);}// Add card draw from conditional effects if applicable\nif(card.effects.conditional_effect&&card.effects.conditional_effect.condition==='land_type'&&card.effects.conditional_effect.land_type===tile.landType&&card.effects.conditional_effect.effects.draw){drawCount+=card.effects.conditional_effect.effects.draw;}// Draw cards if needed\nif(drawCount>0){const{drawnCards,newDeck:updatedDeck,newDiscard:updatedDiscard}=drawCards(newDeck,newDiscard,drawCount);newHand=[...newHand,...drawnCards];newDeck=updatedDeck;newDiscard=updatedDiscard;}// Check for game over conditions\nconst{gameOver,victory}=checkGameOver({...gameState,player:newPlayerState});// Update game state\nsetGameState({...gameState,grid:newGrid,hand:newHand,deck:newDeck,discard:newDiscard,player:newPlayerState,selectedCard:null,gameOver,victory,specialState});};// Handle completing an Archives card action\nconst handleArchivesComplete=()=>{var _gameState$specialSta2;if(((_gameState$specialSta2=gameState.specialState)===null||_gameState$specialSta2===void 0?void 0:_gameState$specialSta2.type)!=='archives')return;const discardedCards=gameState.specialState.data.discardedCards||[];// Move discarded cards to discard pile\nlet newHand=[...gameState.hand];let newDiscard=[...gameState.discard];// Remove discarded cards from hand\nnewHand=newHand.filter(card=>!discardedCards.some(c=>c.id===card.id));// Add discarded cards to discard pile\nnewDiscard=[...newDiscard,...discardedCards];// Draw as many cards as were discarded\nconst{drawnCards,newDeck,newDiscard:updatedDiscard}=drawCards(gameState.deck,newDiscard,discardedCards.length);// Update game state\nsetGameState({...gameState,hand:[...newHand,...drawnCards],deck:newDeck,discard:updatedDiscard,specialState:undefined});// Exit discard mode\nsetCardSelectionMode(null);};// Handle buying a card from the shop\nconst handleBuyCard=card=>{// Check if player has enough gold and buys\nif(gameState.player.gold<card.cost||gameState.player.buys<=0){return;}// Handle tech upgrade cards immediately\nif(card.type==='Tech'&&card.effects.tech){// Update player state with tech upgrade\nconst newPlayerState={...gameState.player,gold:gameState.player.gold-card.cost,buys:gameState.player.buys-1,techTier:card.effects.tech};// Update shop with new cards based on tech tier\nconst newShop=generateShopCards(card.effects.tech);// Check for game over conditions\nconst{gameOver,victory}=checkGameOver({...gameState,player:newPlayerState});// Update game state\nsetGameState({...gameState,shop:newShop,player:newPlayerState,gameOver,victory});return;}// Update player state\nconst newPlayerState={...gameState.player,gold:gameState.player.gold-card.cost,buys:gameState.player.buys-1};// Add card to discard pile\nconst newDiscard=[...gameState.discard,card];// Remove card from shop and replace it\nconst newShop=gameState.shop.filter(c=>c.id!==card.id);// Add a new card to the shop\nconst availableCards=generateShopCards(gameState.player.techTier);const cardsNotInShop=availableCards.filter(c=>!newShop.some(shopCard=>shopCard.name===c.name));if(cardsNotInShop.length>0){const randomIndex=Math.floor(Math.random()*cardsNotInShop.length);newShop.push(cardsNotInShop[randomIndex]);}// Update game state\nsetGameState({...gameState,shop:newShop,discard:newDiscard,player:newPlayerState});};// Handle end turn\nconst handleEndTurn=()=>{// If in a special state, handle it first\nif(cardSelectionMode==='discard'){handleArchivesComplete();return;}if(missileDomeSelection){// Force selection to complete\nconst newGrid=JSON.parse(JSON.stringify(gameState.grid));// Apply defense to selected tiles\nmissileDomeSelection.tilesSelected.forEach(_ref3=>{let[r,c]=_ref3;newGrid[r][c].defense+=4;// Missile dome provides +4 defense\n});setMissileDomeSelection(null);setGameState(prev=>({...prev,grid:newGrid}));return;}// Discard remaining hand\nlet newDiscard=[...gameState.discard,...gameState.hand];let newDeck=[...gameState.deck];// Apply damage from pending attacks\nconst{grid:damagedGrid,woundCount}=applyDamageToGrid(gameState.grid,gameState.pendingAttacks);// Add wounds to discard pile\nfor(let i=0;i<woundCount;i++){newDiscard.push(createWoundCard(gameState.player.wounds+i));}// Update player wounds count\nconst newWoundsCount=gameState.player.wounds+woundCount;// Calculate card draw for next turn\nlet nextCardDraw=gameState.player.maxCardDraw;if(newWoundsCount>=4){nextCardDraw-=1;}// Reset player attributes for next turn\nconst newPlayerState={...gameState.player,cardPlays:gameState.player.maxCardPlays,buys:gameState.player.maxBuys,gold:gameState.goldRushEffects||0,// Apply gold rush effects\nwounds:newWoundsCount,cardDraw:nextCardDraw};// Draw new hand for next turn\nlet drawnCards=[];// If deck doesn't have enough cards, shuffle discard into deck\nif(newDeck.length<nextCardDraw&&newDiscard.length>0){console.log('Reshuffling discard pile into deck');// Shuffle discard pile to form new deck\nnewDeck=shuffleDeck([...newDeck,...newDiscard]);newDiscard=[];}// Draw cards\nconst drawResult=drawCards(newDeck,newDiscard,nextCardDraw);drawnCards=drawResult.drawnCards;newDeck=drawResult.newDeck;newDiscard=drawResult.newDiscard;// Reset grid for new turn\nconst newGrid=resetGridForNewTurn(damagedGrid);// Generate pending attacks for the next round\nconst nextRound=gameState.round+1;const pendingAttacks=generatePendingAttacks(nextRound);// Check for game over conditions\nconst{gameOver,victory}=checkGameOver({...gameState,player:newPlayerState});// Update game state\nsetGameState({...gameState,round:nextRound,grid:newGrid,hand:drawnCards,deck:newDeck,discard:newDiscard,player:newPlayerState,selectedCard:null,gameOver,victory,specialState:undefined,pendingAttacks,goldRushEffects:undefined,// Reset gold rush effects\npartialLandBenefits:undefined// Reset partial land benefits\n});};// Handle starting a new game\nconst handleNewGame=()=>{const initialState=initializeGameState();setGameState(initialState);};return/*#__PURE__*/_jsxs(\"div\",{className:\"App\",children:[/*#__PURE__*/_jsx(\"header\",{className:\"App-header\",children:/*#__PURE__*/_jsx(\"h1\",{children:\"Grid Builder\"})}),/*#__PURE__*/_jsxs(\"div\",{className:\"game-container\",children:[/*#__PURE__*/_jsx(PlayerInfo,{playerAttributes:gameState.player,round:gameState.round}),/*#__PURE__*/_jsxs(\"div\",{className:\"game-play-area\",children:[/*#__PURE__*/_jsx(GameBoard,{grid:gameState.grid,selectedCard:gameState.selectedCard,onTileClick:handleCardPlacement,missileDomeSelection:missileDomeSelection,pendingAttacks:gameState.pendingAttacks}),/*#__PURE__*/_jsxs(\"div\",{className:\"side-panel\",children:[/*#__PURE__*/_jsx(ShopArea,{shop:gameState.shop,gold:gameState.player.gold,buys:gameState.player.buys,onBuyCard:handleBuyCard}),/*#__PURE__*/_jsx(\"button\",{className:\"end-turn-button\",onClick:handleEndTurn,children:cardSelectionMode==='discard'?'Confirm Discards':'End Turn'})]})]}),/*#__PURE__*/_jsx(HandArea,{hand:gameState.hand,selectedCard:gameState.selectedCard,onCardSelect:handleCardSelect,cardPlays:gameState.player.cardPlays,selectionMode:cardSelectionMode,selectedForDiscard:((_gameState$specialSta3=gameState.specialState)===null||_gameState$specialSta3===void 0?void 0:_gameState$specialSta3.type)==='archives'?gameState.specialState.data.discardedCards||[]:[]}),gameState.gameOver&&/*#__PURE__*/_jsx(GameOver,{victory:gameState.victory,onNewGame:handleNewGame})]})]});};export default App;","map":{"version":3,"names":["React","useState","useEffect","GameBoard","PlayerInfo","ShopArea","HandArea","GameOver","initializeGameState","drawCards","checkGameOver","resetGridForNewTurn","applyDamageToGrid","generateShopCards","applyLandBenefit","applyCardEffectToTile","applyStoneSkinEffect","generatePendingAttacks","createWoundCard","shuffleDeck","jsx","_jsx","jsxs","_jsxs","App","_gameState$specialSta3","gameState","setGameState","cardSelectionMode","setCardSelectionMode","missileDomeSelection","setMissileDomeSelection","initialState","className","children","handleCardSelect","card","_gameState$specialSta","discardedCards","specialState","type","data","some","c","id","newDiscardedCards","filter","prev","_selectedCard","selectedCard","handleCardPlacement","rowIndex","colIndex","tilesSelected","length","tilesNeeded","_ref","r","newSelection","newGrid","JSON","parse","stringify","grid","forEach","_ref2","defense","setTimeout","cardPlayed","player","cardPlays","tileMap","Map","updatedGrid","tilesModified","newPlayerState","effects","gold","buy","buys","card_play","tech","techTier","special_effect","goldRushEffects","tile","land_benefit","playerAttributes","partialBenefits","landType","land_benefit_double","partialLandBenefits","conditional_effect","condition","land_type","draw","newHand","hand","newDeck","deck","newDiscard","discard","push","drawCount","drawnCards","updatedDeck","updatedDiscard","gameOver","victory","handleArchivesComplete","_gameState$specialSta2","undefined","handleBuyCard","cost","newShop","shop","availableCards","cardsNotInShop","shopCard","name","randomIndex","Math","floor","random","handleEndTurn","_ref3","damagedGrid","woundCount","pendingAttacks","i","wounds","newWoundsCount","nextCardDraw","maxCardDraw","maxCardPlays","maxBuys","cardDraw","console","log","drawResult","nextRound","round","handleNewGame","onTileClick","onBuyCard","onClick","onCardSelect","selectionMode","selectedForDiscard","onNewGame"],"sources":["/home/acker/projects/grid_build/src/App.tsx"],"sourcesContent":["import React, { useState, useEffect } from 'react';\nimport { GameBoard } from './components/GameBoard';\nimport { PlayerInfo } from './components/PlayerInfo';\nimport { ShopArea } from './components/ShopArea';\nimport { HandArea } from './components/HandArea';\nimport { GameOver } from './components/GameOver';\nimport { \n  initializeGameState, \n  drawCards, \n  checkGameOver, \n  resetGridForNewTurn, \n  applyDamageToGrid, \n  generateShopCards,\n  applyLandBenefit,\n  applyCardEffectToTile,\n  applyStoneSkinEffect,\n  getAdjacentTiles,\n  generatePendingAttacks\n} from './utils/gameUtils';\nimport { createWoundCard, getAllCards } from './data/cards';\nimport { shuffleDeck } from './utils/cardUtils';\nimport { GameState, Card, Tile } from './types';\nimport './App.css';\n\nconst App: React.FC = () => {\n  const [gameState, setGameState] = useState<GameState | null>(null);\n  const [cardSelectionMode, setCardSelectionMode] = useState<'play' | 'discard' | null>(null);\n  const [missileDomeSelection, setMissileDomeSelection] = useState<{\n    tilesSelected: [number, number][];\n    tilesNeeded: number;\n  } | null>(null);\n\n  // Initialize game\n  useEffect(() => {\n    // Initialize with cards from our hardcoded set\n    const initialState = initializeGameState();\n    setGameState(initialState);\n  }, []);\n\n  if (!gameState) {\n    return <div className=\"loading\">Loading game data...</div>;\n  }\n\n  // Handle card selection from hand\n  const handleCardSelect = (card: Card) => {\n    if (missileDomeSelection) {\n      // If in missile dome selection mode, ignore card selection\n      return;\n    }\n    \n    if (cardSelectionMode === 'discard') {\n      // In discard mode (for Archives card)\n      const discardedCards = gameState.specialState?.type === 'archives' \n        ? gameState.specialState.data.discardedCards || []\n        : [];\n\n      // Toggle card selection for discard\n      if (discardedCards.some((c: Card) => c.id === card.id)) {\n        // Remove from discard selection\n        const newDiscardedCards = discardedCards.filter((c: Card) => c.id !== card.id);\n        \n        setGameState(prev => ({\n          ...prev!,\n          specialState: {\n            type: 'archives',\n            data: {\n              ...prev!.specialState!.data,\n              discardedCards: newDiscardedCards\n            }\n          }\n        }));\n      } else {\n        // Add to discard selection\n        setGameState(prev => ({\n          ...prev!,\n          specialState: {\n            type: 'archives',\n            data: {\n              ...prev!.specialState!.data,\n              discardedCards: [...discardedCards, card]\n            }\n          }\n        }));\n      }\n    } else {\n      // Regular card selection mode\n      setGameState(prev => ({\n        ...prev!,\n        selectedCard: prev!.selectedCard?.id === card.id ? null : card\n      }));\n    }\n  };\n\n  // Handle card placement on grid\n  const handleCardPlacement = (rowIndex: number, colIndex: number) => {\n    // Handle missile dome selection mode\n    if (missileDomeSelection) {\n      if (missileDomeSelection.tilesSelected.length < missileDomeSelection.tilesNeeded) {\n        // Add this tile to missile dome selection if not already selected\n        if (!missileDomeSelection.tilesSelected.some(([r, c]) => r === rowIndex && c === colIndex)) {\n          const newSelection = {\n            tilesSelected: [...missileDomeSelection.tilesSelected, [rowIndex, colIndex] as [number, number]],\n            tilesNeeded: missileDomeSelection.tilesNeeded\n          };\n          \n          setMissileDomeSelection(newSelection);\n          \n          // If we've selected all needed tiles, apply the defense\n          if (newSelection.tilesSelected.length === newSelection.tilesNeeded) {\n            const newGrid = JSON.parse(JSON.stringify(gameState.grid)) as Tile[][];\n            \n            // Apply defense to selected tiles\n            newSelection.tilesSelected.forEach(([r, c]) => {\n              newGrid[r][c].defense += 4; // Missile dome provides +4 defense\n            });\n            \n            // Finish the missile dome action\n            setTimeout(() => {\n              setMissileDomeSelection(null);\n              setGameState(prev => ({\n                ...prev!,\n                grid: newGrid\n              }));\n            }, 500);\n          }\n        }\n      }\n      return;\n    }\n    \n    if (!gameState.selectedCard) return;\n    \n    // Check if a card has already been played on this tile\n    if (gameState.grid[rowIndex][colIndex].cardPlayed) return;\n    \n    // Check if player has enough card plays\n    if (gameState.player.cardPlays <= 0) return;\n    \n    const card = gameState.selectedCard;\n    \n    // Track tiles that have cards played on them in this turn\n    const tileMap = new Map<string, boolean>();\n    \n    // Create a deep copy of the grid\n    let newGrid = JSON.parse(JSON.stringify(gameState.grid)) as Tile[][];\n    \n    // Apply the basic card effect to the tile\n    const { grid: updatedGrid, tilesModified } = applyCardEffectToTile(\n      newGrid, \n      rowIndex, \n      colIndex, \n      card,\n      tileMap\n    );\n    \n    newGrid = updatedGrid;\n    \n    // Calculate effects from the card\n    let newPlayerState = { ...gameState.player };\n    \n    // Decrease card plays\n    newPlayerState.cardPlays -= 1;\n    \n    // Apply card effects\n    if (card.effects.gold) {\n      newPlayerState.gold += card.effects.gold;\n    }\n    \n    if (card.effects.buy) {\n      newPlayerState.buys += card.effects.buy;\n    }\n    \n    if (card.effects.card_play) {\n      newPlayerState.cardPlays += card.effects.card_play;\n    }\n    \n    if (card.effects.tech) {\n      newPlayerState.techTier = card.effects.tech;\n      if (newPlayerState.techTier > 5) {\n        newPlayerState.techTier = 5;\n      }\n    }\n    \n    // Handle special effects\n    let specialState = gameState.specialState;\n    \n    if (card.effects.special_effect === 'missile_dome') {\n      // Enter missile dome selection mode - handled by a different function\n      setMissileDomeSelection({\n        tilesSelected: [[rowIndex, colIndex]], // The initial tile is already selected\n        tilesNeeded: 2 // Missile dome defends 2 tiles\n      });\n    } else if (card.effects.special_effect === 'archives') {\n      // Enter archives mode - discard and draw\n      specialState = {\n        type: 'archives',\n        data: {\n          discardedCards: []\n        }\n      };\n      setCardSelectionMode('discard');\n    } else if (card.effects.special_effect === 'stone_skin') {\n      // Apply Stone Skin effect to all tiles that had cards played on them\n      newGrid = applyStoneSkinEffect(newGrid, tileMap);\n    } else if (card.effects.special_effect === 'gold_rush') {\n      // Track gold rush effect for next turn\n      setGameState(prev => ({\n        ...prev!,\n        goldRushEffects: (prev!.goldRushEffects || 0) + 2\n      }));\n    }\n    \n    // Apply land benefit if card has that effect\n    const tile = gameState.grid[rowIndex][colIndex];\n    if (card.effects.land_benefit) {\n      const { playerAttributes, partialBenefits } = applyLandBenefit(\n        tile.landType, \n        newPlayerState, \n        card.effects.land_benefit_double,\n        gameState.partialLandBenefits\n      );\n      newPlayerState = playerAttributes;\n      \n      // Update game state with new partial benefits\n      setGameState(prev => ({\n        ...prev!,\n        partialLandBenefits: partialBenefits\n      }));\n    }\n    \n    // Apply conditional effects based on land type\n    if (card.effects.conditional_effect && \n        card.effects.conditional_effect.condition === 'land_type' &&\n        card.effects.conditional_effect.land_type === tile.landType) {\n      \n      if (card.effects.conditional_effect.effects.gold) {\n        newPlayerState.gold += card.effects.conditional_effect.effects.gold;\n      }\n      \n      if (card.effects.conditional_effect.effects.draw) {\n        // Will handle card drawing later\n      }\n    }\n    \n    // Handle card drawing effects\n    let newHand = [...gameState.hand];\n    let newDeck = [...gameState.deck];\n    let newDiscard = [...gameState.discard];\n    \n    // Remove the played card from hand (unless it's a special effect that stays in play)\n    newHand = newHand.filter(c => c.id !== card.id);\n    \n    // Add the played card to the discard pile\n    newDiscard.push(card);\n    \n    // Handle card draw effects\n    let drawCount = 0;\n    if (card.effects.draw) {\n      drawCount += card.effects.draw;\n    }\n    \n    // Add card draw from land benefit if applicable\n    if (card.effects.land_benefit && tile.landType === 'card') {\n      drawCount += 1 * (card.effects.land_benefit_double ? 2 : 1);\n    }\n    \n    // Add card draw from conditional effects if applicable\n    if (card.effects.conditional_effect && \n        card.effects.conditional_effect.condition === 'land_type' &&\n        card.effects.conditional_effect.land_type === tile.landType &&\n        card.effects.conditional_effect.effects.draw) {\n      \n      drawCount += card.effects.conditional_effect.effects.draw;\n    }\n    \n    // Draw cards if needed\n    if (drawCount > 0) {\n      const { drawnCards, newDeck: updatedDeck, newDiscard: updatedDiscard } = \n        drawCards(newDeck, newDiscard, drawCount);\n      \n      newHand = [...newHand, ...drawnCards];\n      newDeck = updatedDeck;\n      newDiscard = updatedDiscard;\n    }\n    \n    // Check for game over conditions\n    const { gameOver, victory } = checkGameOver({\n      ...gameState,\n      player: newPlayerState\n    });\n    \n    // Update game state\n    setGameState({\n      ...gameState,\n      grid: newGrid,\n      hand: newHand,\n      deck: newDeck,\n      discard: newDiscard,\n      player: newPlayerState,\n      selectedCard: null,\n      gameOver,\n      victory,\n      specialState\n    });\n  };\n\n  // Handle completing an Archives card action\n  const handleArchivesComplete = () => {\n    if (gameState.specialState?.type !== 'archives') return;\n    \n    const discardedCards = gameState.specialState.data.discardedCards || [];\n    \n    // Move discarded cards to discard pile\n    let newHand = [...gameState.hand];\n    let newDiscard = [...gameState.discard];\n    \n    // Remove discarded cards from hand\n    newHand = newHand.filter(card => \n      !discardedCards.some((c: Card) => c.id === card.id)\n    );\n    \n    // Add discarded cards to discard pile\n    newDiscard = [...newDiscard, ...discardedCards];\n    \n    // Draw as many cards as were discarded\n    const { drawnCards, newDeck, newDiscard: updatedDiscard } = \n      drawCards(gameState.deck, newDiscard, discardedCards.length);\n    \n    // Update game state\n    setGameState({\n      ...gameState,\n      hand: [...newHand, ...drawnCards],\n      deck: newDeck,\n      discard: updatedDiscard,\n      specialState: undefined\n    });\n    \n    // Exit discard mode\n    setCardSelectionMode(null);\n  };\n\n  // Handle buying a card from the shop\n  const handleBuyCard = (card: Card) => {\n    // Check if player has enough gold and buys\n    if (gameState.player.gold < card.cost || gameState.player.buys <= 0) {\n      return;\n    }\n    \n    // Handle tech upgrade cards immediately\n    if (card.type === 'Tech' && card.effects.tech) {\n      // Update player state with tech upgrade\n      const newPlayerState = {\n        ...gameState.player,\n        gold: gameState.player.gold - card.cost,\n        buys: gameState.player.buys - 1,\n        techTier: card.effects.tech\n      };\n      \n      // Update shop with new cards based on tech tier\n      const newShop = generateShopCards(card.effects.tech);\n      \n      // Check for game over conditions\n      const { gameOver, victory } = checkGameOver({\n        ...gameState,\n        player: newPlayerState\n      });\n      \n      // Update game state\n      setGameState({\n        ...gameState,\n        shop: newShop,\n        player: newPlayerState,\n        gameOver,\n        victory\n      });\n      \n      return;\n    }\n    \n    // Update player state\n    const newPlayerState = {\n      ...gameState.player,\n      gold: gameState.player.gold - card.cost,\n      buys: gameState.player.buys - 1\n    };\n    \n    // Add card to discard pile\n    const newDiscard = [...gameState.discard, card];\n    \n    // Remove card from shop and replace it\n    const newShop = gameState.shop.filter(c => c.id !== card.id);\n    \n    // Add a new card to the shop\n    const availableCards = generateShopCards(gameState.player.techTier);\n    const cardsNotInShop = availableCards.filter(\n      c => !newShop.some(shopCard => shopCard.name === c.name)\n    );\n    \n    if (cardsNotInShop.length > 0) {\n      const randomIndex = Math.floor(Math.random() * cardsNotInShop.length);\n      newShop.push(cardsNotInShop[randomIndex]);\n    }\n    \n    // Update game state\n    setGameState({\n      ...gameState,\n      shop: newShop,\n      discard: newDiscard,\n      player: newPlayerState\n    });\n  };\n\n  // Handle end turn\n  const handleEndTurn = () => {\n    // If in a special state, handle it first\n    if (cardSelectionMode === 'discard') {\n      handleArchivesComplete();\n      return;\n    }\n    \n    if (missileDomeSelection) {\n      // Force selection to complete\n      const newGrid = JSON.parse(JSON.stringify(gameState.grid)) as Tile[][];\n      \n      // Apply defense to selected tiles\n      missileDomeSelection.tilesSelected.forEach(([r, c]) => {\n        newGrid[r][c].defense += 4; // Missile dome provides +4 defense\n      });\n      \n      setMissileDomeSelection(null);\n      \n      setGameState(prev => ({\n        ...prev!,\n        grid: newGrid\n      }));\n      \n      return;\n    }\n    \n    // Discard remaining hand\n    let newDiscard = [...gameState.discard, ...gameState.hand];\n    let newDeck = [...gameState.deck];\n    \n    // Apply damage from pending attacks\n    const { grid: damagedGrid, woundCount } = applyDamageToGrid(\n      gameState.grid, \n      gameState.pendingAttacks\n    );\n    \n    // Add wounds to discard pile\n    for (let i = 0; i < woundCount; i++) {\n      newDiscard.push(createWoundCard(gameState.player.wounds + i));\n    }\n    \n    // Update player wounds count\n    const newWoundsCount = gameState.player.wounds + woundCount;\n    \n    // Calculate card draw for next turn\n    let nextCardDraw = gameState.player.maxCardDraw;\n    if (newWoundsCount >= 4) {\n      nextCardDraw -= 1;\n    }\n    \n    // Reset player attributes for next turn\n    const newPlayerState = {\n      ...gameState.player,\n      cardPlays: gameState.player.maxCardPlays,\n      buys: gameState.player.maxBuys,\n      gold: gameState.goldRushEffects || 0, // Apply gold rush effects\n      wounds: newWoundsCount,\n      cardDraw: nextCardDraw\n    };\n    \n    // Draw new hand for next turn\n    let drawnCards: Card[] = [];\n    \n    // If deck doesn't have enough cards, shuffle discard into deck\n    if (newDeck.length < nextCardDraw && newDiscard.length > 0) {\n      console.log('Reshuffling discard pile into deck');\n      // Shuffle discard pile to form new deck\n      newDeck = shuffleDeck([...newDeck, ...newDiscard]);\n      newDiscard = [];\n    }\n    \n    // Draw cards\n    const drawResult = drawCards(newDeck, newDiscard, nextCardDraw);\n    drawnCards = drawResult.drawnCards;\n    newDeck = drawResult.newDeck;\n    newDiscard = drawResult.newDiscard;\n    \n    // Reset grid for new turn\n    const newGrid = resetGridForNewTurn(damagedGrid);\n    \n    // Generate pending attacks for the next round\n    const nextRound = gameState.round + 1;\n    const pendingAttacks = generatePendingAttacks(nextRound);\n    \n    // Check for game over conditions\n    const { gameOver, victory } = checkGameOver({\n      ...gameState,\n      player: newPlayerState\n    });\n    \n    // Update game state\n    setGameState({\n      ...gameState,\n      round: nextRound,\n      grid: newGrid,\n      hand: drawnCards,\n      deck: newDeck,\n      discard: newDiscard,\n      player: newPlayerState,\n      selectedCard: null,\n      gameOver,\n      victory,\n      specialState: undefined,\n      pendingAttacks,\n      goldRushEffects: undefined, // Reset gold rush effects\n      partialLandBenefits: undefined // Reset partial land benefits\n    });\n  };\n\n  // Handle starting a new game\n  const handleNewGame = () => {\n    const initialState = initializeGameState();\n    setGameState(initialState);\n  };\n\n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">\n        <h1>Grid Builder</h1>\n      </header>\n      <div className=\"game-container\">\n        <PlayerInfo \n          playerAttributes={gameState.player} \n          round={gameState.round} \n        />\n        <div className=\"game-play-area\">\n          <GameBoard \n            grid={gameState.grid} \n            selectedCard={gameState.selectedCard}\n            onTileClick={handleCardPlacement}\n            missileDomeSelection={missileDomeSelection}\n            pendingAttacks={gameState.pendingAttacks}\n          />\n          <div className=\"side-panel\">\n            <ShopArea \n              shop={gameState.shop} \n              gold={gameState.player.gold}\n              buys={gameState.player.buys}\n              onBuyCard={handleBuyCard} \n            />\n            <button \n              className=\"end-turn-button\" \n              onClick={handleEndTurn}\n            >\n              {cardSelectionMode === 'discard' ? 'Confirm Discards' : 'End Turn'}\n            </button>\n          </div>\n        </div>\n        <HandArea \n          hand={gameState.hand} \n          selectedCard={gameState.selectedCard}\n          onCardSelect={handleCardSelect} \n          cardPlays={gameState.player.cardPlays}\n          selectionMode={cardSelectionMode}\n          selectedForDiscard={\n            gameState.specialState?.type === 'archives' \n              ? gameState.specialState.data.discardedCards || []\n              : []\n          }\n        />\n        {gameState.gameOver && (\n          <GameOver \n            victory={gameState.victory} \n            onNewGame={handleNewGame} \n          />\n        )}\n      </div>\n    </div>\n  );\n};\n\nexport default App;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}